use std::cmp::Ordering;
use super::ClientOrderId;
use barter_integration::model::{Exchange, Instrument, Side};
use serde::{Deserialize, Serialize};
use std::fmt::{Display, Formatter};

/// Todo:
#[derive(Clone, Eq, PartialEq, PartialOrd, Debug, Deserialize, Serialize)]
pub struct Order<State> {
    pub exchange: Exchange,
    pub instrument: Instrument,
    pub cid: ClientOrderId,
    pub state: State,
}

/// The initial state of an [`Order`]. Sent to the [`ExecutionClient`](crate::ExecutionClient) for
/// actioning.
#[derive(Copy, Clone, PartialEq, PartialOrd, Debug, Deserialize, Serialize)]
pub struct RequestOpen {
    pub kind: OrderKind,
    pub side: Side,
    pub price: f64,
    pub quantity: f64,
}

/// Type of [`Order`].
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Deserialize, Serialize)]
pub enum OrderKind {
    Market,
    Limit,
    PostOnly,
    ImmediateOrCancel,
}

impl Display for OrderKind {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                OrderKind::Market => "market",
                OrderKind::Limit => "limit",
                OrderKind::PostOnly => "post_only",
                OrderKind::ImmediateOrCancel => "immediate_or_cancel",
            }
        )
    }
}

/// State of an [`Order`] after a [`RequestOpen`] has been sent to the
/// [`ExecutionClient`](crate::ExecutionClient), but a confirmation response has not been received.
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Deserialize, Serialize)]
pub struct InFlight;

/// State of an [`Order`] after a request has been made for it to be [`Cancelled`].
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Deserialize, Serialize)]
pub struct RequestCancel;

/// Todo:
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
pub struct Open {
    pub id: OrderId,
    pub side: Side,
    pub price: f64,
    pub quantity: f64,
    pub filled_quantity: f64,
}

// Buy a quantity of base for some quote price
// eg/ Market Buy 1.0 btc at 100 usdt price
// Ergo, increases btc by 1, decreases usdt by (1 * 100)

// Sell a quantity of base for some quote price
// eg/ Market Sell 1.0 btc at 100 usdt price
// Ergo, decreases btc by 1, increases usdt by (1 * 100)

impl Open {
    pub fn remaining_quantity(&self) -> f64 {
        self.quantity - self.filled_quantity
    }
}

impl Ord for Order<Open> {
    fn cmp(&self, other: &Self) -> Ordering {
        // Todo: Order by Amount too
        self.state
            .price
            .partial_cmp(&other.state.price)
            .unwrap_or_else(|| panic!("{}.partial_cmp({}) impossible", self.state.price, other.state.price))
    }
}

impl PartialOrd for Order<Open> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        match self.state.price.partial_cmp(&other.state.price)? {
            Ordering::Equal => self.state.quantity.partial_cmp(&other.state.quantity),
            non_equal => Some(non_equal),
        }
    }
}

impl Eq for Order<Open> {}

/// State of an [`Order`] after being [`Cancelled`].
#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Deserialize, Serialize)]
pub struct Cancelled {
    id: OrderId,
}

/// [`Order`] identifier generated by an exchange. Cannot assume this is unique across each
/// [`Exchange`](barter_integration::model::Exchange),
/// [`Market`](barter_integration::model::Market), or
/// [`Instrument`](barter_integration::model::Instrument).
#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Deserialize, Serialize)]
pub struct OrderId(pub String);

impl<S> From<S> for OrderId
where
    S: Into<String>,
{
    fn from(id: S) -> Self {
        Self(id.into())
    }
}

impl From<&Order<RequestOpen>> for Order<InFlight> {
    fn from(request: &Order<RequestOpen>) -> Self {
        Self {
            exchange: request.exchange.clone(),
            instrument: request.instrument.clone(),
            cid: request.cid,
            state: InFlight,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_util::order_open;

    #[test]
    fn test_partial_ord_order_open() {
        struct TestCase {
            input_one: Order<Open>,
            input_two: Order<Open>,
            expected: Option<Ordering>,
        }

        let cases = vec![
            TestCase { // TC0: Input One has higher price and higher quantity -> Greater
                input_one: order_open(Side::Buy, 1100.0, 2.0, 0.0),
                input_two: order_open(Side::Buy, 1000.0, 1.0, 0.0),
                expected: Some(Ordering::Greater)
            },
            TestCase { // TC1: Input One has higher price but same quantity -> Greater
                input_one: order_open(Side::Buy, 1100.0, 1.0, 0.0),
                input_two: order_open(Side::Buy, 1000.0, 1.0, 0.0),
                expected: Some(Ordering::Greater)
            },
            TestCase { // TC2: Input One has higher price but lower quantity -> Greater
                input_one: order_open(Side::Buy, 1100.0, 1.0, 0.0),
                input_two: order_open(Side::Buy, 1000.0, 2.0, 0.0),
                expected: Some(Ordering::Greater)
            },
            TestCase { // TC3: Input One has same price and higher quantity -> Greater
                input_one: order_open(Side::Buy, 1000.0, 2.0, 0.0),
                input_two: order_open(Side::Buy, 1000.0, 1.0, 0.0),
                expected: Some(Ordering::Greater)
            },
            TestCase { // TC4: Input One has same price and same quantity -> Equal
                input_one: order_open(Side::Buy, 1000.0, 1.0, 0.0),
                input_two: order_open(Side::Buy, 1000.0, 1.0, 0.0),
                expected: Some(Ordering::Equal)
            },
            TestCase { // TC5: Input One has same price but lower quantity -> Less
                input_one: order_open(Side::Buy, 1000.0, 1.0, 0.0),
                input_two: order_open(Side::Buy, 1000.0, 2.0, 0.0),
                expected: Some(Ordering::Less)
            },
            TestCase { // TC6: Input One has lower price but higher quantity -> Less
                input_one: order_open(Side::Buy, 1000.0, 2.0, 0.0),
                input_two: order_open(Side::Buy, 1100.0, 1.0, 0.0),
                expected: Some(Ordering::Less)
            },
            TestCase { // TC7: Input One has lower price and same quantity -> Less
                input_one: order_open(Side::Buy, 1000.0, 1.0, 0.0),
                input_two: order_open(Side::Buy, 1100.0, 1.0, 0.0),
                expected: Some(Ordering::Less)
            },
            TestCase { // TC8: Input One has lower price but lower quantity -> Less
                input_one: order_open(Side::Buy, 1000.0, 1.0, 0.0),
                input_two: order_open(Side::Buy, 1100.0, 2.0, 0.0),
                expected: Some(Ordering::Less)
            },
        ];

        for (index, test) in cases.into_iter().enumerate() {
            let actual = test.input_one.partial_cmp(&test.input_two);
            match (actual, test.expected) {
                (None, None) => {
                    // Test passed
                }
                (Some(actual), Some(expected)) => {
                    assert_eq!(actual, expected, "TC{} failed", index)
                },
                (actual, expected) => {
                    // Test failed
                    panic!("TC{index} failed because actual != expected. \nActual: {actual:?}\nExpected: {expected:?}\n");
                }
            }
        }
    }



















}